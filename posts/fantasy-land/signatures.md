---
slug: fantasy-land/signatures
tag: fantasy-land
chapter: 2
title: Cигнатуры Дамаса-Хиндли-Милнера
origin: http://www.tomharding.me/2017/03/08/fantas-eel-and-specification-2/
---

# Сигнатуры


Приветствую, путешественник. Надеюсь, ты отличненько угорел по первой части этой серии. В конце статьи я упоминал – есть ещё одна малюсенькая вещь, о которой, по моему мнению, нам стоит поговорить перед тем, как нырять в Fantasy Land: [сигнатуры Дамаса-Хиндли-Милнера.](https://en.wikipedia.org/wiki/Hindley–Milner_type_system)

Без паники.

## Введение: `Java -> Haskell`

Скорее всего ты уже встречал языки с явным (**статическим**) указанием типов. Например, Java:

```java
public static void main(String[] args) {}
```


Это строка описывает функцию `main`, которая принимает массив значений типа `String` и возвращает `void` (то есть ничего не возвращает). Это **сигнатура** функции. Сигнатуры Дамаса-Хиндли-Милнера – это просто другой способ записи типов. Знаешь что? Давай прибережём печатные символы и в дальнейшем будем называть их просто *сигнатурами*.

Когда мы будем рассматривать примеры, имей в виду: **все** функции каррированы. Я уже писал о [каррировании в JavaScript](http://www.tomharding.me/2016/11/12/curry-on-wayward-son/), так что освежи в памяти, если не чувствуешь уверенности в себе. **TL;DR**: там, где мы объявили бы функцию `add` в Java-подобных языках вот так:

```java
public static int add(int a, int b);
//                     ^ arg  ^ arg
//             ^ return
```

Мы напишем сигнатуру *каррированной* функции вот так:

```haskell
add :: Int -> Int -> Int
--      ^  arg ^ arg
--                    ^ return
```

Переведу на русский: тут написано, что функция `add` принимает число `x` и возвращает функцию, которая, в свою очередь, принимает число `y` и возвращает число (возможно, `x + y`).

> Да, ты можешь задаться вопросом, как же быть с функциями в JavaScript, которые не являются каррированными? Например, функция `add` с такой сигнатурой: `(Int, Int) -> Int`. Условимся, что это будет функция, *единственный* аргумент которой является парой значений (**кортежем**). JavaScript, увы, немного не вписывается в эту концепцию, в чём мы будем убеждаться вновь и вновь.

Давай взглянем на `zipWith`, немного более сложный пример. Вот одна из возможных реализаций на JavaScript:

```js
const zipWith = f => xs => ys => {
  const length = Math.min(
    xs.length,
    ys.length,
  )

  return Array.from(
		{ length },
		(_, i) => f(xs[i])(ys[i]),
	)
}

zipWith(x => y => x + y)([1, 2])([4, 5, 6]) // [ 5, 7 ]
```

Наша прекрасная функция `zipWith` последовательно берёт значения по индексу из двух массивов (пока не закончится кратчайший), применяет на них функцию `f` и возвращает массив результатов. *Если не совсем понятно, как работает эта функция, повызывай её с разными аргументами, прежде чем продолжать.* Давай подумаем о типах:

- Функция `f` принимает два аргумента двух разных типов (назовём их `a` и `b`), это должны быть соответствующие типы значений массивов `xs` и `ys`.
- Функция `zipWith` возвращает массив значений, тип которых – это тип, возрвращаемый функцией `f`. Таким образом, если `f` возвращает некий тип `c`, то `zipWith(f)` должна возрващать массив значений типа `c`.

Как написать сигнатуру для такой функции? Всё просто:

```haskell
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
```

Мы использовали переменные типов (type variables), чтобы обозначить "места", где мы можем использовать различные типы (тебе может быть известна эта идея под названием "**полиморфизм**"). Не обязательно называть их `a`, `b` и `c` – можешь использовать `x`, `dog` и `jeff` (но не надо). *Единственное правило – имена переменных типов всегда начинаются с буквы в нижнем регистре, а имена конкретных типов – с буквы в верхнем регистре.*

Так как мы можем подставить вместо переменной `a` *любой* тип (если типы `f` и `xs` согласуются!), мы можем описать *одну* сигнатуру `zipWith`, которая работает для *любого* типа `a`. Круть, да? На самом деле, `zipWith` – великолепный пример инструмента, с которым мы будем встречаться повсеместно в функциональном коде, всё *из-за переменных типов*, делающих функцию такой гибкой:

```jsx
// a = Int
// b = String
// c = Bool

zipWith(x => y => y.length > x)
  ([3, 5])(['Good', 'Bad']) // [ true, false ]
```

Здесь наша переменная типа `a` принимает значение конкретного типа `Int`, `b` принимает значение `String`, а `c` – `Bool`. Так же мы могли бы привести их все к `Int` и `zip`'нуть с `x => y => x + y`. Надеюсь, ты управишься с охватившим тебя трепетом. Вот ещё один пример функции с переменными типов:

```jsx
// Фильтруем массив с помощью предиката
// filter :: (a -> Bool) -> [a] -> [a]
const filter = p => xs => xs.filter(p)
```

Наша функция будет работать для любого `a` до тех пор, пока функция `p` будет знать, как превратить `a` в `Bool`. Ае!

Обрати внимание, что и `filter`, и `zipWith` принимают в качестве аргумента функцию. Чтобы отобразить это в сигнатуре, мы размещаем сигнатуру внутренней функции (заключая в круглые скобки) внутри сигнатуры внешней функции.

По сути, это всё. Мы разделяем каждый тип с помощью `->`, тот что в конце – тип возвращаемого значения, все остальные – аргументы. На самом деле, это всё, что тебе нужно знать, чтобы читать и писать сигнатуры типов на [Elm](https://elm-lang.org) — [сходи и попиши чего-нибудь на Elm](http://www.tomharding.me/2016/12/11/the-orrery/)!

Однако, для этой серии статей, нам придётся немного усложнить дело и представить ещё пару вещей...

## Ограничения типов (Type Constraints)

`zipWith` и `filter` великолепны, ведь их переменные типов могут принимать *любой* тип. К сожалению, мы не всегда можем позволить себе такую роскошь. Мы можем столкнуться с сигнатурами вроде такой:

```haskell
equals :: Setoid a => a -> a -> Bool
```

`=>` – это новая нотация. Она означает, что сигнатура *справа* от `=>` валидна, когда все условия из *левой* части соблюдены. В случае `equals` сигнатура `a -> a -> Bool` валидна, если `a` является `Setoid`. Пока не задумывайся, что такое `Setoid`, мы поговорим об этом следующей статье. Пока представь себе, что `Setoid` – это тип, который позволяет произвести проверку, являются ли два значения этого типа эквивалентными.

Ограничения очень важны. Когда мы смотрим на сигнатуру, содержащую переменные типов без ограничений, мы с уверенностью можем сказать, что функция никак **не может взаимодействовать** с этими значениями. Когда мы читаем сигнатуру `id ::  a -> a`, мы понимаем – функция должна вернуть переданное ей значение, ведь мы ничего не знаем про `a`, это может быть число, функция или что вообще что угодно! Это приводит нас к идее [параметрического полиморфизма](https://en.wikipedia.org/wiki/Parametric_polymorphism), мы к нему ещё не раз вернёмся.

В языках вроде Haskell компилятор на этапе компиляции производит проверки, что условия в левой части соблюдены – это позволяет обнаружить множество ошибок ещё до запуска программы. Для нас же, как мы убедимся в будущем, это просто *очень удобный* способ документирования.

## OOP-lease Stop

Это не был бы JavaScript, если бы у нас не было хаков, не так ли? Из-за того, что JavaScript такой, какой он есть, мы будем описывать наши типы с методами, определёнными на прототипах. Например, `equals`:

```jsx
// Вместо функции:
equals(first)(second)

// Мы используем методы:
first.equals(second)
```

Если честно, то на первый взгляд выглядит поудобнее. Однако, методы не состыковываются с нашими прекрасными сигнатурами, ведь `equals` теперь – это не функция с двумя аргументами, это метод, принимающий в качестве аргумента одно значение, определённый на прототипе другого значения. Не забываем, что аргумент должен иметь тот же тип, что и объект, на прототипе которого определён метод `equals`. В спецификации Fantasy Land ты встретишь вот такой способ выражения подобной связи:

```haskell
equals :: Setoid a => a ~> a -> Bool
```

`~>` – это новая нотация. Она значит, что `equals` – это метод, определённый на том, что находится слева от `~>`, а справа – сигнатура этого метода. В прошлой статье мы встречались с методом `List.prototype.toArray`. Его сигнатура в стиле Fantasy Land выглядела бы так:

```jsx
// toArray :: List a ~> [a]
List.prototype.toArray = function () {
  return this.cata({
    Cons: (x, acc) => [
      x, ... acc.toArray()
    ],

    Nil: () => []
  })
}
```

Эта сигнатура говорит нам, что у `List` значений типа `a` есть метод `toArray`, который возвращает массив значений типа `a`. Может, это и не суперклассно выглядит, но это JavaScript. *Если хочется поупражняться – напиши сигнатуру для `List.prototype.map` и сделай её настолько универсальной, насколько это возможно.*

## `finish :: Blog ~> Ending`

Вот мы и закончили. Это всё, что тебе необходимо знать, чтобы жить полной насыщенной жизнью функциональщика. Это как ездить на велосипеде со странными стрелочками и скобочками со всех сторон – однажды научившись ты уже не разучишься. Если статья показалась тебе сложноватой – ничего страшного. Просто возвращайся к ней, чтобы освежить воспоминания, если при чтении следующих статей будут возникать вопросы.

Всё, погнали. Больше никаких лирических отступлений. Следующая остановка – **Fantasy Land**. 


Береги себя! ❤️
