---
slug: fantasy-land/setoid
tag: fantasy-land
chapter: 3
title: Setoid
description: Сетоиды
date: 2021-02-12
---


# Setoid

**Поздравляю!** Ты освоил [основы `daggy`](/fantasy-land/daggy), проникся введением в [сигнатуры типов](/fantasy-land/signatures) и готов приступить к путешествию через волшебные земли Fantasy land. Первый пункт на нашей карте – setoid.

**Setoid** – это любой тип, подразумевающий идею **эквивалентности**. Ты уже используешь setoid'ы (числа, строки, логический тип) – каждый раз, когда ты обращаешься к оператору `==`, так что эта тема не должна показаться сложной. Кроме того, ты используешь штуки, которые *не являются* setoid'ами. Например, **функции**.

> Это может показаться странным, но на самом деле – как мы можем *достоверно* знать, что две функции эквивалентны? Компилятор может заверить нас, что `100 * 10` эквивалентно `1000`. Однако у компилятора не найдётся достаточно смелости, чтобы заявить, что `x => x * x` эквивалентно `x => Math.pow(x, 2)`. Это на самом деле не самая тривиальная вещь! *

Итак, чтобы тип был совместимым по спецификации Fantasy Land setoid'ом, на его прототипе должен быть определён метод `equals` со следующей сигнатурой:

```haskell
equals :: Setoid a => a ~> a -> Boolean
```

Надеюсь, не очень страшно. Просто способ указать, что одна сущность эквивалентна другой. Давай реализуем несколько setoid'ов на основе кода из [первой статьи](/fantasy-land/daggy):

```js
// Проверка на эквивалентность точек
// equals :: Coord ~> Coord -> Bool
Coord.prototype.equals = function (that) {
  return this.x === that.x
      && this.y === that.y
      && this.z === that.z
}

// Проверка каждой точки с помощью Coord.equals
// equals :: Line ~> Line -> Bool
Line.prototype.equals = function (that) {
  return this.from.equals(that.from)
      && this.to.equals(that.to)
}

// Одна "истина" должна совпадать со второй
// equals :: Bool ~> Bool -> Bool
Bool.prototype.equals = function (that) {
  return this.is(Bool.True) === that.is(Bool.True)
}

// Проверяем головы списков, затем их хвосты
// equals :: Setoid a => List a ~> List a -> Bool
List.prototype.equals = function (that) {
  return this.cata({
    // Сравнение двух разных setoid'ов
    Cons: (head, tail) =>
      head.equals(that.head) // первый, a
        && tail.equals(that.tail), // и второй, [a]
    Nil: () => that.is(List.Nil)
  })
}
```

Ты уловил суть, да? Для нескольких конструкторов мы производим проверки для соответствующего **конструктора**. Если конструктор(ы) принима(ет/ют) аргументы, мы, вероятно, производим проверки и для аргументов. Очевидно, если мы производим эти проверки, то **аргументы тоже должны быть `setoid`'ами**, иначе как мы могли бы удостовериться в их эквивалентности?

Это и есть причина, по которой на методе `equals` типа `List` есть ограничение по типу (элементы списка обязательно должны быть `setoid`'ами): мы должны иметь возможность проверить *всю* структуру, целиком и полностью!

К сожалению, имеется кособокий побочный эффект от использования javascript: мы должны использовать `===` или `.equals`, отталкиваясь от типа сравниваемых значений – являются ли они примитивами, или нет. Грустненько. В других языках мы могли бы **переопределить** поведение оператора `===` для собственных типов, но не в javascript. Ты, конечно, можешь определить `.equals` на прототипах примитивов, но это считается плохой практикой (и называется "манкипатчинг"). *Никогда не играйся со стандартными прототипами*.

Как бы то ни было, эти имплементации `.equals` достаточно симпатичные, не так ли?

---

Все структуры Fantasy Land сопровождаются законами. Они должны соблюдаться для корректности имплементации. `Setoid` – не исключение. Для полной уверенности, что твой `setoid` будет совместим с другими библиотеками и алгоритмами, нужно помнить о трёх простых вещах. 

Всегда:
- `a.equals(a) === true`, закон **рефлексивности**.
- `a.equals(b) === b.equals(a)`, закон **симметрии** или закон **коммутативности** – перемена мест операндов не влияет на результат. А вот операция вычитания *не коммутативна*, как и [некоторые другие](https://www.quora.com/Is-floating-point-addition-commutative-and-associative), которые могут тебя позабавить.
- Если истинно `a.equals(b)` и `b.equals(c)`, то `a.equals(c)` тоже истинно. Это закон **транзитивности**.

Можно с лёгкостью убедиться, что эти законы исполняются всеми написанными выше имплементациями `.equals`, *до тех пор, пока мы соблюдаем сигнатуру!*

Если ни один из этих законов не озадачил тебя, то у меня отличные новости! Это значит, что у тебя хорошая интуиция сущности `Setoid`'а. Позже мы познакомимся с более сложными структурами и такая твоя интуиция очень пригодится для понимания, как эти структуры *использовать*.

Если теперь ты *жаждешь* поупражняться, то почему бы не реализовать метод `.equals` для встроенного типа `Array` так, чтобы сделать любой массив `Setoid`'ом? Определи метод на `Array.prototype`, я никому не расскажу б этом. И не забудь убедиться, что твой `Setoid` удовлетворяет законам, что мы обсуждали выше.

Также, если бы ты захотел, смог бы с лёгкостью **вывести** функцию `notEquals` благодаря нашему прекрасному `Setoid`'у и его методу `.equals`:

```js
// notEquals :: Setoid a => a -> a -> Bool
const notEquals = x => y => ...
```

Если же ты не очень жаждешь упражнений (или ты уже утолил эту жажду), то давай перейдём к сути. Ради чего это всё? Если у нас есть формальные определения `Setoid`'ов для сущностей (какими бы прямолинейными ни были эти определения), мы можем определить **интуитивно понятные интерфейсы** для работы с данными любого вида. Например, вот эта функция:

```haskell
nub :: Setoid a => [a] -> [a]
```

*Мне кажется, имя `nub` могло бы быть моим любимым именем для любой функции.* На деле `nub` принимает массив и возвращает его копию, отфильтрованную от дубликатов. И всё! Ты мог встречать её под именем `uniq`. На первый взгляд, реализовать её на JavaScript проще простого:

```js
const nub = xs =>
  xs.filter(
    (x, i) => xs.indexOf(x) === i
  )
```

Это *неплохое* решение, но тут есть проблема: для ссылочных типов (не примитивов) эта функция будет работать только для значений, эквивалентных по ссылке. Но обычно это не наш случай: если исполнить `[[]].indexOf([])`, в результате мы получим `-1`, даже если мы своими глазами видим, что это точно такой же массив `[]`! Как исправить эту проблему? `Setoid` спешит на помощь!

```js
// indexOf :: Setoid a => [a] -> a -> Int
const indexOf = xs => x => {
    for (let i = 0; i < xs.length; i++)
      if (xs[i].equals(x)) return i
    
    return -1
}

// nub_ :: Setoid a => [a] -> [a]
const nub_ = xs => xs.filter(
  (x, i) => indexOf(xs)(x) === i
)
```

Теперь у нас есть функция, которая корректно работает с любым массивом `Setoid`'ов. Если мы уверены, что нашу функцию будут использовать ответственно (передавая туда только массивы `Setoid`'ов), мы даже можем добавить исключительное поведение для работы с примитивами – в точности так, как работает [механизм определения эквивалентности в Ramda](https://github.com/ramda/ramda/blob/v0.23.0/src/internal/_equals.js#L22)!

---

Мне кажется, упоминания `Setoid`'ов (и `Eq`, так они называются в экосистеме Haskell) чаще всего встречаются в контексте функций, работающих с `List` и `Array`. Эти функции предоставляют массу возможностей для создания упражнений на закрепление понимания `Setoid`'ов.

- Реализуй функцию, которая определяет, является ли переданный ей массив **палиндромом** (то есть, эквивалентен ли этот список *инвертированной* версии самого себя). Чтобы функция работала в общем случае, нужно ограничение – параметр функции должен быть массивом `Setoid`'ов. *Маленькая подсказка: ты можешь написать простое решение, используя функцию `zipWith`, которую мы упоминали ранее...*

- Используя `daggy`, создай свой тип `Set_` – тип, который хранит множество уникальных значений. Можешь воспользоваться уже написанной `nub_`! Необходимо реализовать методы для **добавления** и **удаления** элементов, причём для реализации первого понадобится метод для проверки, содержится ли такой элемент во внутреннем хранилище (возможно, это будет массив).

`Setoid` – это, без сомнений, простейшая структура в спецификации Fantasy Land, из-за чего он идеально подходит для начала изучения. Интуиция, необходимая для его понимания, для большинства окажется совершенно естественной, и ни один из законов не должен шокировать.

Но не расслабляйся! В следующий раз мы познакомимся с куда более странной и замечательной структурой: `Semigroup`. Бууууууу 👻

Я надеюсь, тебе понравился этот пост. Если есть предложения или замечания – [милости прошу](https://twitter.com/am_i_tom). Я очень хочу сделать эту серию постов максимально полезной. Не стесняйся просить больше примеров, упражнений или объяснений. А, ну и как всегда:

Береги себя ❤️

---

*\* Важный нюанс здесь в том, что понятие эквивалентности **гораздо глубже**, чем эквивалентность указателей. Просто попробуй ввести `(x => x) === (x => x)` в Node REPL.*

###### [Ссылка на оригинал](http://www.tomharding.me/2017/03/09/fantas-eel-and-specification-3/)

---

## Примечание переводчика

Я тоже надеюсь, что пост тебе понравился. В отличие от Тома, я только начинаю свой путь в чудесную страну Fantasy Land. И я хочу сделать эту серию переводов максимально качественной (может быть, даже расширяя материал Тома). Поэтому не стесняйся задавать вопросы, предлагать изменения и указывать на ошибки в [комментах к анонсам](https://t.me/kekpek_dev) и/или создавать [issues на github](https://github.com/meff34/kekpek.dev/issues/new?assignees=meff34&labels=translation-mistake&template=-----------------.md&title=). 

Ну и, само собой, ❤️
