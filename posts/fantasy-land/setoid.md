---
slug: fantasy-land/setoid
tag: fantasy-land
chapter: 3
title: Setoid
description: Сетоиды
date: 2021-02-12
---


# Setoid

**Поздравляю!** Ты освоил [основы `daggy`](/fantasy-land/daggy), проникся введением в [сигнатуры типов](/fantasy-land/signatures) и теперь готов приступить к путешествию через волшебные земли Fantasy Land. Первый пункт на нашей карте – setoid.

**Setoid** (далее **сетоид**) – это любой тип, подразумевающий идею **эквивалентности**. Ты уже используешь сетоиды, такие, как строки, числа или логический тип, каждый раз, когда обращаешься к оператору `==`. Поэтому эта тема не должна показаться слишком сложной. Кроме того, ты используешь штуки, которые не являются сетоидами, например функции.

> Как мы можем достоверно знать, что две функции эквивалентны? Компилятор может заверить нас, что `100 * 10` эквивалентно `1000`. Однако у компилятора не хватит смелости, чтобы заявить, что `x => x * x` эквивалентно `x => Math.pow(x, 2)`. Это на самом деле не самая тривиальная вещь!

Итак, чтобы тип был совместимым по спецификации Fantasy Land сетоидом, на его прототипе должен быть определён метод `equals` со следующей сигнатурой:


```haskell
equals :: Setoid a => a ~> a -> Boolean
```

Надеюсь, не очень страшно. Это просто способ указать, что одна сущность эквивалентна другой.

Давай реализуем несколько сетоидов на основе кода из [первой статьи](/fantasy-land/daggy):

```js
// Проверка на эквивалентность точек
// equals :: Coord ~> Coord -> Bool
Coord.prototype.equals = function (that) {
  return this.x === that.x
      && this.y === that.y
      && this.z === that.z
}

// Проверка каждой точки с помощью Coord.equals
// equals :: Line ~> Line -> Bool
Line.prototype.equals = function (that) {
  return this.from.equals(that.from)
      && this.to.equals(that.to)
}

// Одна "истина" должна совпадать со второй
// equals :: Bool ~> Bool -> Bool
Bool.prototype.equals = function (that) {
  return this.is(Bool.True) === that.is(Bool.True)
}

// Проверяем головы списков, затем их хвосты
// equals :: Setoid a => List a ~> List a -> Bool
List.prototype.equals = function (that) {
  return this.cata({
    // Сравнение двух разных setoid'ов
    Cons: (head, tail) =>
      head.equals(that.head)       // первый сетоид, a
        && tail.equals(that.tail), // второй сетоид, List a
    Nil: () => that.is(List.Nil)
  })
}
```

Уловил суть? Если у типа несколько конструкторов, то мы производим проверки для соответствующего **конструктора** по отдельности. Если конструктор принимает аргументы, то мы производим проверки и для аргументов. Очевидно, если мы производим эти проверки, то **аргументы тоже должны быть сетоидами**. Иначе как мы могли бы удостовериться в их эквивалентности?

Это и есть причина, по которой на методе `equals` типа `List` есть ограничение по типу: мы должны иметь возможность проверить всю структуру, целиком и полностью! Помни, что элементы списка обязательно должны быть сетоидами.

К сожалению, имеется корявый побочный эффект от использования JavaScript: мы должны использовать `===` или `.equals`, отталкиваясь от типа сравниваемых значений – являются ли они примитивами, или нет. Грустненько. В других языках мы могли бы переопределить поведение оператора `===` для собственных типов, но не в JavaScript. Ты, конечно, можешь определить `.equals` на прототипах примитивов, но это считается плохой практикой и называется "манкипатчинг". **Никогда не играйся со стандартными прототипами**.

Как бы то ни было, эти имплементации `.equals` достаточно симпатичные, не так ли?

## Законы

Все структуры Fantasy Land сопровождаются законами. Они должны соблюдаться для корректности имплементации. Сетоид – не исключение. Для полной уверенности, что твой сетоид будет совместим с другими библиотеками и алгоритмами, нужно помнить о трёх простых вещах. 

Для любого сетоида:

* `a.equals(a) === true`, закон **рефлексивности**.
* `a.equals(b) === b.equals(a)`, закон **симметрии** или закон **коммутативности**, перемена мест операндов не влияет на результат. А вот операция вычитания не коммутативна, как и [некоторые другие](https://www.quora.com/Is-floating-point-addition-commutative-and-associative), которые могут тебя позабавить.
* Если истинно `a.equals(b)` и `b.equals(c)`, то `a.equals(c)` тоже истинно. Это закон **транзитивности**.

Можно с лёгкостью убедиться, что эти законы исполняются всеми написанными выше имплементациями `.equals`. Но только до тех пор, пока мы соблюдаем сигнатуру!

Если ни один из этих законов не озадачил тебя, значит, у тебя хорошая интуиция сущности сетоида. Позже мы познакомимся с более сложными структурами, и интуиция очень пригодится для понимания способов применения этих структур.

Если ты жаждешь поупражняться, то почему бы не реализовать метод `.equals` для встроенного типа `Array` так, чтобы сделать любой массив сетоидом? Определи метод на `Array.prototype`, я никому не расскажу об этом. И не забудь убедиться, что твой сетоид удовлетворяет законам, что мы обсуждали выше.

Также, если бы ты захотел, смог бы с лёгкостью вывести функцию `notEquals`, благодаря нашему прекрасному сетоиду и его методу `.equals`:

```js
// notEquals :: Setoid a => a -> a -> Bool
const notEquals = x => y => ...
```

Если же ты не очень жаждешь упражнений (или уже утолил эту жажду), то давай перейдём к сути. **Ради чего это всё?** Если у нас есть формальные определения сетоидов для сущностей, мы можем определить интуитивно понятные интерфейсы для работы с данными любого вида. Например, вот эта функция:

```haskell
nub :: Setoid a => [a] -> [a]
```

*Хм, мне кажется, имя `nub` могло бы быть моим любимым именем для любой функции.* На деле `nub` принимает массив и возвращает его копию, отфильтрованную от дубликатов. И всё! Ты мог встречать её под именем `uniq`. На первый взгляд, реализовать её на JavaScript проще простого:

```js
const nub = xs =>
  xs.filter((x, i) => xs.indexOf(x) === i)
```

Это неплохое решение, но тут есть проблема: для ссылочных типов (не примитивов) эта функция будет работать только для значений, эквивалентных по ссылке. Но обычно это не наш случай: если исполнить `[[]].indexOf([])`, в результате мы получим `-1`. Даже если мы своими глазами видим, что это точно такой же массив `[]`! Как исправить эту проблему? Сетоид спешит на помощь!

```js
// indexOf :: Setoid a => [a] -> a -> Int
const indexOf = xs => x =>
  xs.findIndex(element => element.equals(x))

// nub_ :: Setoid a => [a] -> [a]
const nub_ = xs =>
  xs.filter((x, i) => indexOf(xs)(x) === i)
```

Теперь у нас есть функция, которая корректно работает с любым массивом сетоидов. Если мы уверены, что нашу функцию будут использовать ответственно, передавая туда только массивы сетоидов, мы даже можем добавить исключительное поведение для работы с примитивами – в точности так, как работает [механизм определения эквивалентности в Ramda](https://github.com/ramda/ramda/blob/v0.23.0/src/internal/_equals.js#L22)!

## Если хочешь поупражняться 

Мне кажется, упоминания сетоидов и `Eq`, так они называются в экосистеме Haskell, чаще всего встречаются в контексте функций, работающих с `List` и `Array`. Эти функции предоставляют массу возможностей для создания упражнений на закрепление понимания сетоидов.

Поупражняйся на этом:

- Реализуй функцию, которая определяет, является ли переданный ей массив палиндромом. То есть, эквивалентен ли этот список инвертированной версии самого себя. Чтобы функция работала в общем случае, нужно ограничение – параметр функции должен быть массивом сетоидов. *Маленькая подсказка: ты можешь написать простое решение, используя функцию `zipWith`, которую мы упоминали ранее.*

- Используя `daggy`, создай свой тип `Set_` – тип, который хранит множество уникальных значений. Можешь воспользоваться уже написанной `nub_`. Необходимо реализовать методы для добавления и удаления элементов. К тому же для реализации первого понадобится метод для проверки, содержится ли такой элемент во внутреннем хранилище. Возможно, внутренним хранилищем будет являться массив. Или нет – решать тебе!

---

Сетоид – это, без сомнений, простейшая структура в спецификации Fantasy Land, из-за чего он идеально подходит для начала изучения. Интуиция, необходимая для его понимания, для большинства окажется совершенно естественной, и ни один из законов не должен шокировать.

Но не расслабляйся! В следующий раз мы познакомимся с куда более странной и замечательной структурой: `Semigroup`. Бууууууу 👻

Я надеюсь, тебе понравился этот пост. Если есть предложения или замечания – [милости прошу](https://twitter.com/am_i_tom). Я очень хочу сделать эту серию постов максимально полезной. Не стесняйся просить больше примеров, упражнений или объяснений. А, ну и как всегда:

Береги себя ❤️

---

> Важный нюанс здесь в том, что понятие эквивалентности **гораздо глубже**, чем эквивалентность указателей. Просто попробуй ввести `(x => x) === (x => x)` в Node REPL.

###### [Ссылка на оригинал](http://www.tomharding.me/2017/03/09/fantas-eel-and-specification-3/)

---

## Примечание переводчика

Я тоже надеюсь, что пост тебе понравился. В отличие от Тома, я только начинаю свой путь в чудесную страну Fantasy Land. И я хочу сделать эту серию переводов максимально качественной. Может быть, даже расширяя материал Тома. 

Не стесняйся задавать вопросы, предлагать изменения и указывать на ошибки в [комментах к анонсам](https://t.me/kekpek_dev) и/или создавать [issues на github](https://github.com/meff34/kekpek.dev/issues/new?assignees=meff34&labels=translation-mistake&template=-----------------.md&title=). 

Ну и, само собой, ❤️
